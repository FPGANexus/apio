"""Scons script of ECP5 FPGAs."""

# -*- coding: utf-8 -*-
# ----------------------------------------------------------------------
# -- Generic Scons script for Sintesizing hardware on an FPGA and more.
# -- This file is part of the Apio project
# -- (C) 2016-2019 FPGAwars
# -- Authors Miodrag Milanovic, Juan Gonzáles, Jesús Arroyo
# -- Licence GPLv2
# ----------------------------------------------------------------------

# W0511: TODO: (fixme)
# pylint: disable=W0511

# C0103: Module name doesn't conform to snake_case naming style (invalid-name)
# pylint: disable=C0103

# C0209: Formatting could be an f-string (consider-using-f-string)
# pylint: disable=C0209

# Similar lines in 2 files
# pylint: disable=R0801

# W0613: Unused argument 'xx' (unused-argument)
# pylint: disable=W0613

# TODO: Can we fix this?
# E0611: No name in module (no-name-in-module)
# pylint: disable=E0611

# TODO: Can we fix this?
# E1101: Instance of 'Base' has no 'X' member (no-member)
# pylint: disable=E1101

# TODO: Remove this disable after moving the functions with 'env' argument
# to scons_util.py.
# W0621: Redefining name 'env' from outer scope (redefined-outer-name)
# pylint: disable=W0621


import os
from platform import system
from SCons.Script import (
    Builder,
    Action,
    AlwaysBuild,
    GetOption,
    Exit,
    COMMAND_LINE_TARGETS,
    ARGUMENTS,
    Glob,
)
from apio.scons_util import (
    get_constraint_file,
    error,
    fatal_error,
    create_construction_env,
    arg_bool,
    arg_str,
    get_verilator_param_str,
    get_programmer_cmd,
    make_verilog_src_scanner,
)

# -- Create the environment
env = create_construction_env(ARGUMENTS)


# -- Get arguments.
FPGA_SIZE = arg_str(env, "fpga_size", "")
FPGA_TYPE = arg_str(env, "fpga_type", "")
FPGA_PACK = arg_str(env, "fpga_pack", "")
TOP_MODULE = arg_str(env, "top_module", "")
FPGA_IDCODE = arg_str(env, "fpga_idcode", "")
VERBOSE_ALL = arg_bool(env, "verbose_all", False)
VERBOSE_YOSYS = arg_bool(env, "verbose_yosys", False)
VERBOSE_PNR = arg_bool(env, "verbose_pnr", False)
TESTBENCH = arg_str(env, "testbench", "")
VERILATOR_ALL = arg_bool(env, "all", False)
VERILATOR_NO_STYLE = arg_bool(env, "nostyle", False)

# Derived from args "nowarn" and "warn".
VERILATOR_PARAM_STR = get_verilator_param_str(env)


# -- Resources paths
IVL_PATH = os.environ["IVL"] if "IVL" in os.environ else ""
TRELLIS_PATH = os.environ["TRELLIS"] if "TRELLIS" in os.environ else ""
DATABASE_PATH = os.path.join(TRELLIS_PATH, "database")
CHIPDB_PATH = os.path.join(TRELLIS_PATH, "chipdb-{0}.txt".format(FPGA_SIZE))
YOSYS_PATH = os.environ["YOSYS_LIB"] if "YOSYS_LIB" in os.environ else ""
YOSYS_CELLS_PATH = f"{YOSYS_PATH}/ecp5/cells_sim.v"

isWindows = "Windows" == system()
VVP_PATH = "" if isWindows or not IVL_PATH else '-M "{0}"'.format(IVL_PATH)
IVER_PATH = "" if isWindows or not IVL_PATH else '-B "{0}"'.format(IVL_PATH)

IDCODE_PARAM = "" if not FPGA_IDCODE else "--idcode {0}".format(FPGA_IDCODE)

FPGA_TYPE_PARAM = "25k" if (FPGA_TYPE == "12k") else "{0}".format(FPGA_TYPE)

# -- Target name
TARGET = "hardware"

# -- Create scannenr to identify dependencies in verilog files.
verilog_src_scanner = make_verilog_src_scanner(env)

# -- Get a list of all the verilog files in the src folfer, in ASCII, with
# -- the full path. All these files are used for the simulation
v_nodes = Glob("*.v")
v_files = [str(f) for f in v_nodes]

# Construct disjoint lists of .v module and testbench files.
src_synth = [f for f in v_files if f[-5:].upper() != "_TB.V"]
list_tb = [f for f in v_files if f[-5:].upper() == "_TB.V"]

# -- Get the LPF file name.
LPF = get_constraint_file(env, ".lpf", TOP_MODULE)

# -- Synthesizing Builder
synth_builder = Builder(
    action='yosys -p "synth_ecp5 {0} -json $TARGET" {1} $SOURCES'.format(
        ("-top " + TOP_MODULE) if TOP_MODULE else "",
        "" if VERBOSE_ALL or VERBOSE_YOSYS else "-q",
    ),
    suffix=".json",
    src_suffix=".v",
    source_scanner=verilog_src_scanner,
)
env.Append(BUILDERS={"Synth": synth_builder})

# -- Place and route Builder.
pnr_builder = Builder(
    action=(
        "nextpnr-ecp5 --{0} --package {1} --json $SOURCE --textcfg $TARGET "
        "--lpf {2} {3} --timing-allow-fail --force"
    ).format(
        FPGA_TYPE_PARAM,
        FPGA_PACK,
        LPF,
        "" if VERBOSE_ALL or VERBOSE_PNR else "-q",
    ),
    suffix=".config",
    src_suffix=".json",
)
env.Append(BUILDERS={"PnR": pnr_builder})

# -- Bitstream Builder.
bitstream_builder = Builder(
    action="ecppack --compress --db {0} {1} $SOURCE hardware.bit".format(
        DATABASE_PATH, IDCODE_PARAM
    ),
    suffix=".bit",
    src_suffix=".config",
)
env.Append(BUILDERS={"Bin": bitstream_builder})

# -- No time analysis report implemented for the ECP5 family
time_rpt_builder = Builder(
    action=(
        'echo "Time analysis report is not impelemnted for the ECP5 family." '
        "> $TARGET"
    ),
    suffix=".rpt",
    src_suffix=".config",
)
env.Append(BUILDERS={"Time": time_rpt_builder})

# -- Generate the bitstream
synth_target = env.Synth(TARGET, [src_synth])
pnr_target = env.PnR(TARGET, [synth_target, LPF])
bin_target = env.Bin(TARGET, pnr_target)
build_target = env.Alias("build", bin_target)

if VERBOSE_YOSYS:
    AlwaysBuild(synth_target)
if VERBOSE_PNR:
    AlwaysBuild(pnr_target)
if VERBOSE_ALL:
    AlwaysBuild(synth_target, pnr_target, build_target)

# -- Upload the bitstream into FPGA
programmer_cmd = get_programmer_cmd(env)
upload_target = env.Alias("upload", bin_target, programmer_cmd)
AlwaysBuild(upload_target)

# -- Target time: calculate the time
time_rpt_target = env.Time(pnr_target)
AlwaysBuild(time_rpt_target)
time_target = env.Alias("time", time_rpt_target)

# -- Icarus Verilog builders


def iverilog_generator(source, target, env, for_signature):
    """Constructs dynamically a commands for iverlog targets builders."""
    # E.g. "my_module" or "my_module_tb"
    target_name, _ = os.path.splitext(str(target[0]))
    # Testbenches use the value macro VCD_OUTPUT to know the name of the waves
    # output file. We also pass a dummy when the verify command to avoid a
    # warning about the undefined macro.
    is_testbench = target_name.upper().endswith("_TB")
    is_verify = "verify" in COMMAND_LINE_TARGETS
    vcd_output_flag = (
        "-D VCD_OUTPUT=dummy_vcd_output"
        if is_verify
        else f"-D VCD_OUTPUT={target_name}" if is_testbench else ""
    )
    verbose_flag = "-v" if VERBOSE_ALL else ""
    # The INTERACTIVE_SIM macro allow testbenchs to distinguish between an
    # automatic simulation (apio test) and interactive simulation (apio sim),
    # For example, for continuing despire errors in interactive mode.
    is_interactive_sim = is_testbench and "sim" in COMMAND_LINE_TARGETS
    interactive_sim_flag = "-D INTERACTIVE_SIM" if is_interactive_sim else ""
    result = (
        "iverilog {0} {1} -o $TARGET {2} {3} -D NO_INCLUDES "
        '"{3}/ecp5/cells_bb.v" "{4}" $SOURCES'
    ).format(
        IVER_PATH,
        verbose_flag,
        vcd_output_flag,
        interactive_sim_flag,
        YOSYS_CELLS_PATH,
    )
    return result


iverilog_builder = Builder(
    # Action string is computed automatically by the generator.
    generator=iverilog_generator,
    suffix=".out",
    src_suffix=".v",
    source_scanner=verilog_src_scanner,
)
env.Append(BUILDERS={"IVerilog": iverilog_builder})

dot_builder = Builder(
    action=(
        "yosys -f verilog -p "
        '"show -format dot -colors 1 -prefix hardware {0}" '
        "{1} $SOURCES"
    ).format(
        TOP_MODULE if TOP_MODULE else "unknown_top",
        "" if VERBOSE_ALL else "-q",
    ),
    suffix=".dot",
    src_suffix=".v",
    source_scanner=verilog_src_scanner,
)
env.Append(BUILDERS={"DOT": dot_builder})

svg_builder = Builder(
    # Expecting graphviz dot to be installed and in the path.
    action="dot -Tsvg $SOURCES -o $TARGET",
    suffix=".svg",
    src_suffix=".dot",
)
env.Append(BUILDERS={"SVG": svg_builder})

# NOTE: output file name is defined in the iverilog call using VCD_OUTPUT macro
vcd_builder = Builder(
    action="vvp {0} $SOURCE".format(VVP_PATH), suffix=".vcd", src_suffix=".out"
)
env.Append(BUILDERS={"VCD": vcd_builder})

# --- Verify
vout_target = env.IVerilog(TARGET, src_synth + list_tb)
AlwaysBuild(vout_target)
verify_target = env.Alias("verify", vout_target)

# --- Graph
# TODO: Launch some portable SVG (or differentn format) viewer.
dot_target = env.DOT(TARGET, src_synth)
AlwaysBuild(dot_target)
svg_target = env.SVG(TARGET, dot_target)
AlwaysBuild(svg_target)
graph_target = env.Alias("graph", svg_target)

# --- Simulation
# Since the simulation targets are dynamic due to the testbench selection, we
# create them only when running simulation.
if "sim" in COMMAND_LINE_TARGETS:
    assert "test" not in COMMAND_LINE_TARGETS, COMMAND_LINE_TARGETS
    if TESTBENCH:
        # Explicit testbench file name is given via --testbench.
        sim_testbench = TESTBENCH
    else:
        # No --testbench flag was specified. If there is exactly one testbench
        # then pick it, otherwise fail.
        if len(list_tb) == 0:
            fatal_error(env, "No testbench found for simulation.")
        if len(list_tb) > 1:
            # TODO: consider to allow specifying the default testbench
            # in apio.ini.
            error(
                env,
                (
                    "Found {} testbranches, please use the --testbench flag."
                ).format(len(list_tb)),
            )
            for tb in list_tb:
                print("- {}".format(tb))
            Exit(1)
        sim_testbench = list_tb[0]  # Pick the only available testbench.
    # Here sim_testbench contains the testbench, e.g. my_module_tb.v.
    # Construct list of files to build.
    src_sim = []
    src_sim.extend(src_synth)  # All the .v files.
    src_sim.append(sim_testbench)
    # Create targets sim target and its dependent.
    sim_name, _ = os.path.splitext(sim_testbench)  # e.g. my_module_tb
    sout_target = env.IVerilog(sim_name, src_sim)
    vcd_file_target = env.VCD(sout_target)
    # 'do_initial_zoom_fit' does max zoom only if .gtkw file not found.
    waves_target = env.Alias(
        "sim",
        vcd_file_target,
        "gtkwave {0} {1} {2}.gtkw".format(
            '--rcvar "splash_disable on" --rcvar "do_initial_zoom_fit 1"',
            vcd_file_target[0],
            sim_name,
        ),
    )
    AlwaysBuild(waves_target)


# --- Testing
# Since the simulation targets are dynamic due to the testbench selection, we
# create them only when running simulation.
if "test" in COMMAND_LINE_TARGETS:
    assert "sim" not in COMMAND_LINE_TARGETS, COMMAND_LINE_TARGETS
    if TESTBENCH:
        # Explicit testbench file name is given via --testbench. We test just
        # that one.
        test_tbs = [TESTBENCH]
    else:
        # No --testbench flag specified. We will test all them.
        if len(list_tb) == 0:
            fatal_error(env, "No testbenchs found for simulation.")
        test_tbs = list_tb  # All testbenches.
    tests = []  # Targets of all tests
    for test_tb in test_tbs:
        # Create a list of source files. All the modules + the current
        # testbench.
        src_test = []
        src_test.extend(src_synth)  # All the .v files.
        src_test.append(test_tb)
        # Create the targets for the 'out' and 'vcd' files of the testbench.
        # NOTE: Remove the two AlwaysBuild() calls below for an incremental
        # test. Fast, correct, but may confuse the user seeing nothing happens.
        test_name, _ = os.path.splitext(test_tb)  # e.g. my_module_tb
        test_out_target = env.IVerilog(test_name, src_test)
        AlwaysBuild(test_out_target)
        test_vcd_target = env.VCD(test_out_target)
        AlwaysBuild(test_vcd_target)
        test_target = env.Alias(test_name, [test_out_target, test_vcd_target])
        tests.append(test_target)
    # Create a target for the test command that depends on all the test
    # targets.
    tests_target = env.Alias("test", tests)
    AlwaysBuild(tests_target)


# -- Verilator config file builder
def verilator_config_func(target, source, env):
    """Creates a verilator .vlt config files."""
    with open(target[0].get_path(), "w", encoding="utf-8") as target_file:
        # NOTE: This config was copied from ICE40. Adjust as needed.
        target_file.write(
            "`verilator_config\n"
            f'lint_off -rule COMBDLY      -file "{YOSYS_CELLS_PATH}"\n'
            f'lint_off -rule WIDTHEXPAND  -file "{YOSYS_CELLS_PATH}"\n'
        )
    return 0


verilator_config_builder = Builder(
    action=Action(verilator_config_func, "Creating verilator config file."),
    suffix=".vlt",
)
env.Append(BUILDERS={"VerilatorConfig": verilator_config_builder})

# -- Verilator builder
verilator_builder = Builder(
    action=(
        "verilator --lint-only --bbox-unsup --timing -Wno-TIMESCALEMOD "
        '-Wno-MULTITOP {0} {1} {2} {3} {4} $SOURCES "{5}"'
    ).format(
        "-Wall" if VERILATOR_ALL else "",
        "-Wno-style" if VERILATOR_NO_STYLE else "",
        VERILATOR_PARAM_STR,
        "--top-module " + TOP_MODULE if TOP_MODULE else "",
        TARGET + ".vlt",
        YOSYS_CELLS_PATH,
    ),
    src_suffix=".v",
    source_scanner=verilog_src_scanner,
)
env.Append(BUILDERS={"Verilator": verilator_builder})

# --- Lint
lint_config_target = env.VerilatorConfig(TARGET, [])
lint_out_target = env.Verilator(TARGET, src_synth + list_tb)
env.Depends(lint_out_target, lint_config_target)
lint_target = env.Alias("lint", lint_out_target)
AlwaysBuild(lint_target)


# -- These is for cleaning the artifact files.
if GetOption("clean"):
    # Identify additional files that may not be associated with targets and
    # associate them with a target such that they will be cleaned up as well.
    # This cleans for example artifacts of past simulation since the testbench
    # target are dynamic and changes with the selected testbench.
    for glob_pattern in ["*.out", "*.vcd"]:
        for node in Glob(glob_pattern):
            env.Clean(time_target, str(node))

    env.Default(
        [
            time_target,
            build_target,
            synth_target,
            pnr_target,
            graph_target,
            lint_target,
        ]
    )
